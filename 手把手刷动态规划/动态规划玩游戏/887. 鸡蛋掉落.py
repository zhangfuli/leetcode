# 给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。
# 已知存在楼层 f ，满足0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。
# 每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。
# 请你计算并返回要确定f确切的值的最小操作次数是多少？
#
# 示例 1：
#
# 输入：k = 1, n = 2
# 输出：2
# 解释：
# 鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。
# 否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。
# 如果它没碎，那么肯定能得出 f = 2 。
# 因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少

# 将问题从： N 个楼层，有 K 个蛋，求最少要扔 T 次，才能保证当 F 无论是 0 <= F <= N 中哪个值，都能测试出来
# 转变为：有 K 个蛋，扔 T 次，求可以确定 F 的个数，然后得出 N 个楼层

# 一个蛋，扔T次，可以确定T-1层楼，一层一层的仍
# 如果只有 1 个蛋，或只有 1 次机会时，只可以确定出 T + 1 个 F
# 其他情况时，递归。【蛋碎了减 1 个，机会减 1 次】 + 【蛋没碎，机会减 1 次】


class Solution:
    def calcF(self, K, T):
        if T == 1 or K == 1:
            return T + 1
        return self.calcF(K - 1, T - 1) + self.calcF(K, T - 1)

    def superEggDrop(self, k, n):
        T = 1
        while self.calcF(k, T) < n + 1:
            T += 1
        return T
